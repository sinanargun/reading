# Reading
Readlist For My Own Craftman World! You know it will take time to get better. Don't quit practising and always strive with 
comfort-zone. You are like a NBA Player. You have to practice every single day. Focus relentlessly more conceptual things rather than techonology.  

> The Pragmatic Programmer

```sh
Some Notes:
  * Refactor Early, Refactor Often
  * Don’t Live with Broken Windows
  * Fix the Problem, Not the Blame
  * Don’t Program by Coincidence
  * Configure, Don’t Integrate
```

> Code Complete (Now)

```sh
Some Notes:

  A confusing abundance of metaphors has grown up around software development.
  David Gries says writing software is a science (1981). Donald Knuth says it\'s an art(1998).
  Watts Humphrey says it\'s a process (1989). P.J. Plauger and Kent Beck say it\'s like driving a car, 
  although they draw nearly opposite conclusions (Plauger 1993, Beck 2000). Alistair CockBurn says it\'s a game (2002).
  Eric Raymond says it\'s like a bazaar (2000). Andy Hunt and Dave Thomas say it\'s like gardening. Paul Heckel says 
  it\'s like filming Snow White and the Seven Dwarfs (1994). Fred Brooks says that it\'s like farming, hunting werewolves,
  or drowning with dinosaurs in a tar pit (1995).
  
  Classes vs. Objects
    A key concept in object-oriented design in the differentiation between objects and classes. An object is any specific entity that exists in your program at run time. A class is the static thing you look at in the program listing. An object is the dynamic thing with specific values and attributes you see when you run the program. For example, you could declare a 
class Person that had attributes of name,age,gender, and so on. At run time you would have the objects nancy,hank,diane,tony and so on-that is, specific instances of the class. If you're familiar with database terms, it's the same as the
distinction between schema and instance. You could think of the class the cookie cutter and the object as the cookie.
    
  When I am working on a problem, I never think about beauty. I think only how to solve the problem. But I have finished if the solution is not beautiful, I know it is wrong.  R.Buckminster Fuller.
  
  From a complexity point of view, the principal benefit of abstraction is that it allows you to ignore irrelevant details. Most real-world objects are already abstractions of some kind. As just mentioned, a house is an abstraction of windows,
doors, siding, wiring, plumbing, insulation and a particular way of organizing them. A door is in turn an abstraction of a particular arrangement of a rectungular piece of material with hinges and a doorknob. And the doorknob is an 
abstraction of a particular formation of brass, nickel, iron or steel. 
  
  Encapsulation picks up where abstraction leaves off. Abstraction says, You are allowed to look at an object
at a high level of detail. Encapsulation says, Furthermore, you aren't allowed to look at an object at any other level of detail.
  
  Continuing with the housing-materials analogy: encapsulation is a way of saying that you can look at the outside of the house but you can't get close enough to make out the door's details. You are allowed to know that there's a door, and you're   allowed to know whether the door is open or closed, but you're not allowed to know whether the door is made of wood, fiberglass,stell, or some other material, and you're certainly not allowed to look at each individual wood fiber.
  
  In designing a software system, you'll often find objects that are much like other objects, except for a few differences. 
  In an accounting system, for instance, you might have both full-time and part-time employees.
  Most of data associated with both kinds of employees is the same, but some is different. 
  In object oriented programming, you can define a general type of employee and then define full-time employees as general employees, except for a few differences, and part-time employees also as general employees, except for a few differences.
  When an operation on an employee doesn't depend on the type of employee, the operation is handled as if the employee were just a general employee.
  When the operation depends on whether the employee is full-time or part-time, the operation is handled differently.
  
  Defining similarities and differences among such objects is called inheritance because the specific part-time 
and full-time employees inherit characteristics from the general-employee type.

 Summary of Reasons to Create a Class
 * Model real-world objects
 * Model abstract objects
 * Reduce complexity
 * Isolate complexity
 * Hide implementation details.
 * Limit effects of changes.
 * Hide global data
 * Streamline parameter passing
 * Make central points of control
 * Facilitate reusable code
 
```

